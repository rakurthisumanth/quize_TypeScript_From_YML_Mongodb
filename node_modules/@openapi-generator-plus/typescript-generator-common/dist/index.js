"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.options = exports.chainTypeScriptGeneratorContext = exports.DateApproach = void 0;
const types_1 = require("@openapi-generator-plus/types");
const types_2 = require("./types");
const path_1 = __importDefault(require("path"));
const handlebars_1 = __importDefault(require("handlebars"));
const handlebars_templates_1 = require("@openapi-generator-plus/handlebars-templates");
const java_like_generator_helper_1 = require("@openapi-generator-plus/java-like-generator-helper");
const generator_common_1 = require("@openapi-generator-plus/generator-common");
const pluralize_1 = __importStar(require("pluralize"));
var types_3 = require("./types");
Object.defineProperty(exports, "DateApproach", { enumerable: true, get: function () { return types_3.DateApproach; } });
function escapeString(value) {
    if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean') {
        throw new Error(`escapeString called with unsupported type: ${typeof value} (${value})`);
    }
    value = String(value);
    value = value.replace(/\\/g, '\\\\');
    value = value.replace(/'/g, '\\\'');
    value = value.replace(/\r/g, '\\r');
    value = value.replace(/\n/g, '\\n');
    return value;
}
function computeCustomTemplatesPath(configPath, customTemplatesPath) {
    if (configPath) {
        return path_1.default.resolve(path_1.default.dirname(configPath), customTemplatesPath);
    }
    else {
        return customTemplatesPath;
    }
}
function toSafeTypeForComposing(nativeType) {
    if (/[^a-zA-Z0-9_.]/.test(nativeType)) {
        return `(${nativeType})`;
    }
    else {
        return nativeType;
    }
}
function chainTypeScriptGeneratorContext(base, add) {
    const result = Object.assign(Object.assign({}, base), { loadAdditionalTemplates: async function (hbs) {
            /* Load the additional first, so that earlier contexts in the chain have priority */
            if (add.loadAdditionalTemplates) {
                await add.loadAdditionalTemplates(hbs);
            }
            if (base.loadAdditionalTemplates) {
                await base.loadAdditionalTemplates(hbs);
            }
        }, additionalWatchPaths: function () {
            const result = [];
            if (base.additionalWatchPaths) {
                result.push(...base.additionalWatchPaths());
            }
            if (add.additionalWatchPaths) {
                result.push(...add.additionalWatchPaths());
            }
            return result;
        }, additionalExportTemplates: async function (outputPath, doc, hbs, rootContext) {
            if (base.additionalExportTemplates) {
                await base.additionalExportTemplates(outputPath, doc, hbs, rootContext);
            }
            if (add.additionalExportTemplates) {
                await add.additionalExportTemplates(outputPath, doc, hbs, rootContext);
            }
        }, defaultNpmOptions: function (config, defaultOptions) {
            let result = defaultOptions;
            if (add.defaultNpmOptions) {
                result = add.defaultNpmOptions(config, result);
            }
            if (base.defaultNpmOptions) {
                result = base.defaultNpmOptions(config, result);
            }
            return result;
        }, defaultTypeScriptOptions: function (config, defaultOptions) {
            let result = defaultOptions;
            if (add.defaultTypeScriptOptions) {
                result = add.defaultTypeScriptOptions(config, result);
            }
            if (base.defaultTypeScriptOptions) {
                result = base.defaultTypeScriptOptions(config, result);
            }
            return result;
        } });
    return result;
}
exports.chainTypeScriptGeneratorContext = chainTypeScriptGeneratorContext;
/* https://github.com/microsoft/TypeScript/issues/2536 */
const RESERVED_WORDS = [
    'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do',
    'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'import',
    'in', 'instanceof', 'new', 'null', 'return', 'super', 'switch', 'this', 'throw', 'true',
    'try', 'typeof', 'var', 'void', 'while', 'with',
    'as', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield',
    'any', 'boolean', 'constructor', 'declare', 'get', 'module', 'require', 'number', 'set', 'string', 'symbol', 'type', 'from', 'of',
];
function options(config, context) {
    const npm = (0, generator_common_1.configObject)(config, 'npm', undefined);
    const defaultRelativeSourceOutputPath = npm ? 'src' : '';
    const relativeSourceOutputPath = (0, generator_common_1.configString)(config, 'relativeSourceOutputPath', defaultRelativeSourceOutputPath);
    const defaultDefaultNpmOptions = {
        name: 'typescript-gen',
        version: '0.0.1',
        private: true,
        repository: null,
    };
    const defaultNpmOptions = context.defaultNpmOptions ? context.defaultNpmOptions(config, defaultDefaultNpmOptions) : defaultDefaultNpmOptions;
    const npmConfig = npm ? {
        name: (0, generator_common_1.configString)(npm, 'name', defaultNpmOptions.name, 'npm.'),
        version: (0, generator_common_1.configString)(npm, 'version', defaultNpmOptions.version, 'npm.'),
        repository: (0, generator_common_1.nullableConfigString)(npm, 'repository', defaultNpmOptions.repository, 'npm.'),
        private: (0, generator_common_1.nullableConfigBoolean)(npm, 'private', defaultNpmOptions.private, 'npm.'),
    } : undefined;
    const defaultDefaultTypeScriptOptions = typeof config.typescript === 'object' ? {
        target: 'ES5',
        libs: ['$target', 'DOM'],
    } : {
        target: 'ES5',
        libs: ['$target', 'DOM'],
    };
    const defaultTypeScriptOptions = context.defaultTypeScriptOptions ? context.defaultTypeScriptOptions(config, defaultDefaultTypeScriptOptions) : defaultDefaultTypeScriptOptions;
    let typeScriptOptions;
    if (config.typescript && typeof config.typescript === 'object') {
        typeScriptOptions = defaultTypeScriptOptions;
        const typescriptConfig = (0, generator_common_1.configObject)(config, 'typescript', {});
        typeScriptOptions.target = (0, generator_common_1.configString)(typescriptConfig, 'target', defaultDefaultTypeScriptOptions.target, 'typescript.');
        typeScriptOptions.libs = (0, generator_common_1.configStringArray)(typescriptConfig, 'libs', defaultDefaultTypeScriptOptions.libs, 'typescript.');
    }
    else if (typeof config.typescript === 'boolean') {
        if (config.typescript) {
            typeScriptOptions = defaultTypeScriptOptions;
        }
        else {
            typeScriptOptions = undefined;
        }
    }
    else if (!npm) {
        /* If we haven't configured an npm package, then assume we don't want tsconfig either */
        typeScriptOptions = undefined;
    }
    else {
        typeScriptOptions = defaultTypeScriptOptions;
    }
    if (typeScriptOptions) {
        typeScriptOptions.libs = typeScriptOptions.libs.map(lib => lib === '$target' ? typeScriptOptions.target : lib);
    }
    const dateApproach = parseDateApproach(config.dateApproach);
    const customTemplates = (0, generator_common_1.configString)(config, 'customTemplates', undefined);
    const defaultBlindDateOptions = {
        dateTimeImplementation: 'OffsetDateTimeString',
    };
    let blindDateOptions;
    if (config.blindDate && typeof config.blindDate === 'object') {
        blindDateOptions = defaultBlindDateOptions;
        const blindDateConfig = (0, generator_common_1.configObject)(config, 'blindDate', {});
        blindDateOptions.dateTimeImplementation = (0, generator_common_1.configString)(blindDateConfig, 'dateTimeImplementation', defaultBlindDateOptions.dateTimeImplementation, 'blindDate.');
    }
    else {
        blindDateOptions = defaultBlindDateOptions;
    }
    const options = Object.assign(Object.assign({}, (0, java_like_generator_helper_1.options)(config, createJavaLikeContext(context))), { relativeSourceOutputPath, npm: npmConfig || null, typescript: typeScriptOptions || null, customTemplatesPath: customTemplates ? computeCustomTemplatesPath(config.configPath, customTemplates) : null, dateApproach, blindDate: blindDateOptions });
    return options;
}
exports.options = options;
function parseDateApproach(approach) {
    if (!approach) {
        return types_2.DateApproach.Native;
    }
    else if (approach === types_2.DateApproach.BlindDate) {
        return types_2.DateApproach.BlindDate;
    }
    else if (approach === types_2.DateApproach.Native) {
        return types_2.DateApproach.Native;
    }
    else if (approach === types_2.DateApproach.String) {
        return types_2.DateApproach.String;
    }
    else {
        throw new Error(`Invalid dateApproach config: ${approach}`);
    }
}
function createJavaLikeContext(context) {
    const javaLikeContext = Object.assign(Object.assign({}, context), { reservedWords: () => RESERVED_WORDS, defaultConstantStyle: "pascalCase" /* pascalCase */ });
    return javaLikeContext;
}
function createGenerator(config, context) {
    const generatorOptions = options(config, context);
    const createdSchemas = new Set();
    const aCommonGenerator = (0, generator_common_1.commonGenerator)(config, context);
    return Object.assign(Object.assign(Object.assign(Object.assign({}, context.baseGenerator(config, context)), aCommonGenerator), (0, java_like_generator_helper_1.javaLikeGenerator)(config, createJavaLikeContext(context))), { toLiteral: (value, options) => {
            if (value === undefined) {
                const defaultValue = context.generator().defaultValue(options);
                if (defaultValue === null) {
                    return null;
                }
                return defaultValue.literalValue;
            }
            if (value === null) {
                return 'null';
            }
            const { type, format, schemaType } = options;
            if (schemaType === types_1.CodegenSchemaType.ENUM) {
                return `${options.nativeType.concreteType}.${context.generator().toEnumMemberName(String(value))}`;
            }
            switch (type) {
                case 'integer': {
                    return `${value}`;
                }
                case 'number': {
                    return `${value}`;
                }
                case 'string': {
                    if (format === 'date') {
                        switch (generatorOptions.dateApproach) {
                            case types_2.DateApproach.Native:
                            case types_2.DateApproach.String:
                                /* Use a string as a JavaScript Date cannot represent a date properly */
                                return `"${value}"`;
                            case types_2.DateApproach.BlindDate:
                                return `toLocalDateString("${value}")`;
                        }
                        throw new Error(`Unsupported date approach: ${generatorOptions.dateApproach}`);
                    }
                    else if (format === 'time') {
                        switch (generatorOptions.dateApproach) {
                            case types_2.DateApproach.Native:
                            case types_2.DateApproach.String:
                                /* Use a string as a JavaScript Date cannot represent a time properly */
                                return `"${value}"`;
                            case types_2.DateApproach.BlindDate:
                                return `toLocalTimeString("${value}")`;
                        }
                        throw new Error(`Unsupported date approach: ${generatorOptions.dateApproach}`);
                    }
                    else if (format === 'date-time') {
                        switch (generatorOptions.dateApproach) {
                            case types_2.DateApproach.Native:
                                /* The date-time format should be an ISO datetime with an offset timezone */
                                return `new Date("${value}")`;
                            case types_2.DateApproach.BlindDate:
                                return `to${generatorOptions.blindDate.dateTimeImplementation}("${value}")`;
                            case types_2.DateApproach.String:
                                return `"${value}"`;
                        }
                        throw new Error(`Unsupported date approach: ${generatorOptions.dateApproach}`);
                    }
                    else {
                        return `'${escapeString(String(value))}'`;
                    }
                }
                case 'boolean':
                    return `${value}`;
                case 'object':
                case 'anyOf':
                case 'oneOf':
                    if (typeof value === 'string') {
                        return value;
                    }
                    else if (typeof value === 'object') {
                        return JSON.stringify(value);
                    }
                    else {
                        context.log(types_1.CodegenLogLevel.WARN, `Literal value of type ${typeof value} is unsupported for schema type object: ${(0, generator_common_1.debugStringify)(value)}`);
                        return 'null';
                    }
                    break;
                case 'file':
                    throw new Error(`Cannot format literal for type ${type}`);
                case 'array': {
                    const arrayValue = Array.isArray(value) ? value : [value];
                    const component = options.component;
                    if (!component) {
                        throw new Error(`toLiteral cannot format array literal without a component type: ${value}`);
                    }
                    return `[${arrayValue.map(v => context.generator().toLiteral(v, Object.assign(Object.assign({}, component.schema), component))).join(', ')}]`;
                }
            }
            throw new Error(`Unsupported literal type name "${type}" in options: ${(0, generator_common_1.debugStringify)(options)}`);
        }, toNativeType: (options) => {
            const { schemaType } = options;
            /* See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types */
            switch (schemaType) {
                case types_1.CodegenSchemaType.INTEGER: {
                    return new context.NativeType('number');
                }
                case types_1.CodegenSchemaType.NUMBER: {
                    return new context.NativeType('number');
                }
                case types_1.CodegenSchemaType.DATE:
                    switch (generatorOptions.dateApproach) {
                        case types_2.DateApproach.Native:
                        case types_2.DateApproach.String:
                            /* We use strings for date and time as JavaScript Date can't support */
                            return new context.NativeType('string');
                        case types_2.DateApproach.BlindDate:
                            return new context.NativeType('LocalDateString');
                    }
                    throw new Error(`Unsupported date approach: ${generatorOptions.dateApproach}`);
                case types_1.CodegenSchemaType.TIME:
                    switch (generatorOptions.dateApproach) {
                        case types_2.DateApproach.Native:
                        case types_2.DateApproach.String:
                            /* We use strings for date and time as JavaScript Date can't support */
                            return new context.NativeType('string');
                        case types_2.DateApproach.BlindDate:
                            return new context.NativeType('LocalTimeString');
                    }
                    throw new Error(`Unsupported date approach: ${generatorOptions.dateApproach}`);
                case types_1.CodegenSchemaType.DATETIME:
                    switch (generatorOptions.dateApproach) {
                        case types_2.DateApproach.Native:
                            /* We don't have a mapping library to convert incoming and outgoing JSON, so the rawType of dates is string */
                            return new context.NativeType('Date', {
                                serializedType: 'string',
                            });
                        case types_2.DateApproach.BlindDate:
                            return new context.NativeType(`${generatorOptions.blindDate.dateTimeImplementation}`);
                        case types_2.DateApproach.String:
                            return new context.NativeType('string');
                    }
                    throw new Error(`Unsupported date approach: ${generatorOptions.dateApproach}`);
                case types_1.CodegenSchemaType.STRING: {
                    return new context.NativeType('string');
                }
                case types_1.CodegenSchemaType.BOOLEAN: {
                    return new context.NativeType('boolean');
                }
                case types_1.CodegenSchemaType.BINARY: {
                    /* Subclasses override this with a type appropriate to their environment, such as blob */
                    return new context.NativeType('string');
                }
            }
            throw new Error(`Unsupported schema type: ${schemaType}`);
        }, toNativeObjectType: function (options) {
            const { scopedName } = options;
            let modelName = 'Api';
            for (const name of scopedName) {
                modelName += `.${context.generator().toClassName(name)}`;
            }
            return new context.NativeType(modelName);
        }, toNativeArrayType: (options) => {
            const { componentNativeType } = options;
            return new context.TransformingNativeType(componentNativeType, {
                default: (nativeType) => `${toSafeTypeForComposing(nativeType.componentType ? nativeType.componentType.nativeType : nativeType.nativeType)}[]`,
            });
        }, toNativeMapType: (options) => {
            const { keyNativeType, componentNativeType } = options;
            return new context.ComposingNativeType([keyNativeType, componentNativeType], {
                default: (nativeTypes) => {
                    return `{ [name: ${nativeTypes[0].componentType ? nativeTypes[0].componentType.nativeType : nativeTypes[0].nativeType}]: ${nativeTypes[1].componentType ? nativeTypes[1].componentType.nativeType : nativeTypes[1].nativeType} }`;
                },
            });
        }, nativeTypeUsageTransformer: ({ nullable }) => ({
            default: function (nativeType, nativeTypeString) {
                if (nullable) {
                    return `${toSafeTypeForComposing(nativeTypeString)} | null`;
                }
                return nativeTypeString;
            },
            /* We don't transform the concrete type as the concrete type is never null; we use it to make new objects */
            concreteType: null,
        }), defaultValue: (options) => {
            const { schemaType, required } = options;
            if (!required) {
                return { value: null, literalValue: 'undefined' };
            }
            switch (schemaType) {
                case types_1.CodegenSchemaType.NUMBER: {
                    const literalValue = context.generator().toLiteral(0.0, options);
                    if (literalValue === null) {
                        return null;
                    }
                    return { value: 0.0, literalValue };
                }
                case types_1.CodegenSchemaType.INTEGER: {
                    const literalValue = context.generator().toLiteral(0, options);
                    if (literalValue === null) {
                        return null;
                    }
                    return { value: 0, literalValue };
                }
                case types_1.CodegenSchemaType.BOOLEAN:
                    return { value: false, literalValue: 'false' };
                case types_1.CodegenSchemaType.ARRAY:
                    return { value: [], literalValue: '[]' };
                case types_1.CodegenSchemaType.MAP:
                    return { value: {}, literalValue: '{}' };
                default:
                    return { value: null, literalValue: 'undefined' };
            }
        }, initialValue: () => {
            /* TypeScript generators don't use initial values */
            return null;
        }, operationGroupingStrategy: () => {
            return context.operationGroupingStrategies.addToGroupsByTagOrPath;
        }, allOfStrategy: () => types_1.CodegenAllOfStrategy.OBJECT, anyOfStrategy: () => types_1.CodegenAnyOfStrategy.NATIVE, oneOfStrategy: () => types_1.CodegenOneOfStrategy.NATIVE, supportsInheritance: () => true, supportsMultipleInheritance: () => true, nativeCompositionCanBeScope: () => true, nativeComposedSchemaRequiresName: () => false, nativeComposedSchemaRequiresObjectLikeOrWrapper: () => false, interfaceCanBeNested: () => true, watchPaths: () => {
            const result = [path_1.default.resolve(__dirname, '..', 'templates')];
            if (context.additionalWatchPaths) {
                result.push(...context.additionalWatchPaths());
            }
            if (generatorOptions.customTemplatesPath) {
                result.push(generatorOptions.customTemplatesPath);
            }
            return result;
        }, cleanPathPatterns: () => undefined, templateRootContext: () => {
            return Object.assign(Object.assign({}, aCommonGenerator.templateRootContext()), generatorOptions);
        }, exportTemplates: async (outputPath, doc) => {
            const hbs = handlebars_1.default.create();
            (0, handlebars_templates_1.registerStandardHelpers)(hbs, context);
            await (0, handlebars_templates_1.loadTemplates)(path_1.default.resolve(__dirname, '..', 'templates'), hbs);
            if (context.loadAdditionalTemplates) {
                await context.loadAdditionalTemplates(hbs);
            }
            if (generatorOptions.customTemplatesPath) {
                await (0, handlebars_templates_1.loadTemplates)(generatorOptions.customTemplatesPath, hbs);
            }
            const rootContext = context.generator().templateRootContext();
            if (generatorOptions.npm) {
                await (0, handlebars_templates_1.emit)('package', path_1.default.join(outputPath, 'package.json'), Object.assign(Object.assign({}, rootContext), generatorOptions.npm), true, hbs);
                await (0, handlebars_templates_1.emit)('gitignore', path_1.default.join(outputPath, '.gitignore'), Object.assign(Object.assign({}, rootContext), doc), true, hbs);
            }
            if (generatorOptions.typescript) {
                await (0, handlebars_templates_1.emit)('tsconfig', path_1.default.join(outputPath, 'tsconfig.json'), Object.assign(Object.assign({}, rootContext), generatorOptions.typescript), true, hbs);
            }
            if (context.additionalExportTemplates) {
                await context.additionalExportTemplates(outputPath, doc, hbs, rootContext);
            }
        }, postProcessSchema: (schema, helper) => {
            if (createdSchemas.has(schema)) {
                /* Skip schemas we create below */
                return;
            }
            /* We don't have access to the completed schema when we create the native type, so we post-process to change the native type
               to represent the disjunctions that we support.
             */
            if ((0, types_1.isCodegenOneOfSchema)(schema) || (0, types_1.isCodegenAnyOfSchema)(schema)) {
                /* If the schema is anonymous (wasn't actually named in the spec) then we
                   replace it with its disjunction wherever it appears, and remove it from
                   the output.

                   If it's not anonymous, then we retain the type as it will be output as a
                   disjunction (or equivalent).
                 */
                if (schema.anonymous) {
                    schema.nativeType.nativeType = schema.composes.map(s => s.nativeType.parentType).join(' | ');
                    schema.nativeType.serializedType = schema.nativeType.nativeType;
                    schema.nativeType.componentType = null;
                    if (!schema.schemas) {
                        /* We can remove this schema as it was anonymous and it doesn't contain any nested schemas that we need to output */
                        return false;
                    }
                }
            }
            else if ((0, types_1.isCodegenObjectSchema)(schema) && schema.discriminator && schema.children) {
                createDisjunction(schema, schema.discriminator.references.map(r => r.schema));
            }
            else if ((0, types_1.isCodegenInterfaceSchema)(schema) && schema.discriminator && schema.implementors) {
                createDisjunction(schema, schema.discriminator.references.map(r => r.schema));
            }
            /**
             * Create a new disjunction schema to represent the possible schemas that a type might be.
             * @param schema
             * @param members
             */
            function createDisjunction(schema, members) {
                let disjunction;
                const scope = helper.scopeOf(schema);
                if (!(0, pluralize_1.isPlural)(schema.name) && !helper.findSchema((0, pluralize_1.default)(schema.name), scope)) {
                    disjunction = helper.createOneOfSchema((0, pluralize_1.default)(schema.name), scope, types_1.CodegenSchemaPurpose.GENERAL);
                    helper.addToScope(disjunction, scope);
                }
                else {
                    disjunction = helper.createOneOfSchema('children', schema, types_1.CodegenSchemaPurpose.GENERAL);
                    helper.addToScope(disjunction, schema);
                }
                disjunction.composes.push(...members);
                createdSchemas.add(disjunction);
                schema.nativeType.nativeType = disjunction.nativeType.nativeType;
                schema.nativeType.serializedType = schema.nativeType.nativeType;
            }
        }, checkAllOfInheritanceCompatibility: (allOfSummary) => {
            /* We output discriminator properties in our interfaces with fixed values, so we cannot then _extend_ that interface
               and declare a different value, so we have to say we cannot use inheritance.
             */
            if (allOfSummary.discriminators.length && allOfSummary.referenceSchemas.length > 1) {
                return false;
            }
            return true;
        } });
}
exports.default = createGenerator;
