"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.discoverDiscriminatorReferencesInOtherDocuments = exports.postProcessSchemaForDiscriminator = exports.addToAnyDiscriminators = exports.addToDiscriminator = exports.loadDiscriminatorMappings = exports.toCodegenSchemaDiscriminator = void 0;
const types_1 = require("@openapi-generator-plus/types");
const _1 = require(".");
const idx = __importStar(require("@openapi-generator-plus/indexed-type"));
const utils_1 = require("../utils");
const vendor_extensions_1 = require("../vendor-extensions");
const utils_2 = require("./utils");
/**
 * Create a CodegenDiscriminator for the given schema, to be put into the target
 * @param apiSchema the schema containing the discriminator
 * @param target the CodegenDiscriminatorSchema where the discriminator will go
 * @param state
 * @returns
 */
function toCodegenSchemaDiscriminator(apiSchema, target, state) {
    if (!apiSchema.discriminator) {
        return null;
    }
    let schemaDiscriminator = apiSchema.discriminator;
    if (typeof schemaDiscriminator === 'string') {
        /* OpenAPIv2 support */
        const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
        schemaDiscriminator = {
            propertyName: schemaDiscriminator,
            /* Note that we support a vendor extension here to allow mappings in OpenAPI v2 specs */
            mapping: vendorExtensions ? vendorExtensions['x-discriminator-mapping'] : undefined,
        };
    }
    let discriminatorType = undefined;
    if ((0, types_1.isCodegenObjectSchema)(target) || (0, types_1.isCodegenHierarchySchema)(target)) {
        const discriminatorProperty = (0, utils_2.findProperty)(target, schemaDiscriminator.propertyName);
        if (!discriminatorProperty) {
            throw new Error(`Discriminator property "${schemaDiscriminator.propertyName}" missing from "${target.name}"`);
        }
        discriminatorType = (0, utils_1.extractCodegenSchemaUsage)(discriminatorProperty);
    }
    else if ((0, types_1.isCodegenAnyOfSchema)(target) || (0, types_1.isCodegenOneOfSchema)(target)) {
        /* For an anyOf or oneOf schemas we have to look in their composes to find the property */
        discriminatorType = findCommonDiscriminatorPropertyType(schemaDiscriminator.propertyName, target.composes, target);
    }
    else if ((0, types_1.isCodegenInterfaceSchema)(target)) {
        /* First check if the interface has the property, which is the case if it's the root of an allOf */
        const discriminatorProperty = (0, utils_2.findProperty)(target, schemaDiscriminator.propertyName);
        if (discriminatorProperty) {
            discriminatorType = (0, utils_1.extractCodegenSchemaUsage)(discriminatorProperty);
        }
        else {
            /* Or for a oneOf interface, look in its implementors */
            discriminatorType = findCommonDiscriminatorPropertyType(schemaDiscriminator.propertyName, target.implementors || [], target);
        }
    }
    else {
        throw new Error(`Unsupported schema type for discriminator: ${target.schemaType}`);
    }
    const result = Object.assign({ name: state.generator.toIdentifier(schemaDiscriminator.propertyName), serializedName: schemaDiscriminator.propertyName, mappings: toCodegenDiscriminatorMappings(schemaDiscriminator), references: [] }, discriminatorType);
    return result;
}
exports.toCodegenSchemaDiscriminator = toCodegenSchemaDiscriminator;
/**
 * Make sure we load any models referenced by the discriminator, as they may not be
 * in our components/schemas that we load automatically, such as when they're in external
 * documents.
 *
 * NOTE: this is separated from toCodegenSchemaDiscriminator as we must not load additional schemas
 *       until the schema has its own discriminator set, otherwise we will not be able to find and add
 *       new schemas to the discriminator.
 */
function loadDiscriminatorMappings(schema, state) {
    if (!schema.discriminator || !schema.discriminator.mappings) {
        return;
    }
    for (const mappingRef of Object.keys(schema.discriminator.mappings)) {
        (0, _1.toCodegenSchemaUsage)({ $ref: mappingRef }, state, {
            required: false,
            suggestedName: `${schema.name}`,
            purpose: types_1.CodegenSchemaPurpose.GENERAL,
            suggestedScope: (0, types_1.isCodegenScope)(schema) ? schema : null,
        });
    }
}
exports.loadDiscriminatorMappings = loadDiscriminatorMappings;
function toCodegenDiscriminatorMappings(discriminator) {
    if (!discriminator.mapping) {
        return null;
    }
    const schemaMappings = {};
    for (const mapping in discriminator.mapping) {
        const ref = discriminator.mapping[mapping];
        schemaMappings[ref] = mapping;
    }
    return schemaMappings;
}
function findDiscriminatorPropertyInObjectSchema(serializedName, schema) {
    if (schema.properties) {
        const property = idx.get(schema.properties, serializedName);
        if (property) {
            return property;
        }
    }
    if (schema.parents) {
        for (const parent of schema.parents) {
            const property = findDiscriminatorPropertyInObjectSchema(serializedName, parent);
            if (property !== undefined) {
                return property;
            }
        }
    }
    return undefined;
}
function findDiscriminatorPropertyInAllOfSchema(serializedName, schema) {
    const n = schema.composes.length;
    for (let i = n - 1; i >= 0; i--) {
        const composedSchema = schema.composes[i];
        if ((0, types_1.isCodegenObjectSchema)(composedSchema)) {
            const property = findDiscriminatorPropertyInObjectSchema(serializedName, composedSchema);
            if (property !== undefined) {
                return property;
            }
        }
        else if ((0, types_1.isCodegenAllOfSchema)(composedSchema)) {
            const property = findDiscriminatorPropertyInAllOfSchema(serializedName, composedSchema);
            if (property !== undefined) {
                return property;
            }
        }
    }
    return undefined;
}
/**
 * Find the common discriminator property type for a named discimrinator property across a collection of schemas.
 * @param serializedName the serialized name of the property
 * @param schemas the schemas to look for the property in
 * @param container the container of the discriminator property
 * @returns
 */
function findCommonDiscriminatorPropertyType(serializedName, schemas, container) {
    let result = undefined;
    for (const schema of schemas) {
        let property;
        if ((0, types_1.isCodegenObjectSchema)(schema)) {
            property = findDiscriminatorPropertyInObjectSchema(serializedName, schema);
        }
        else if ((0, types_1.isCodegenAllOfSchema)(schema)) {
            property = findDiscriminatorPropertyInAllOfSchema(serializedName, schema);
        }
        else {
            throw new Error(`Found unexpected schema type (${schema.schemaType}) when looking for discriminator property "${serializedName}" for "${container.name}"`);
        }
        if (property === undefined) {
            throw new Error(`Discriminator property "${serializedName}" for "${container.name}" missing in "${schema.name}"`);
        }
        const propertyType = (0, utils_1.extractCodegenSchemaUsage)(property);
        if (result === undefined) {
            result = propertyType;
        }
        else if (!(0, utils_1.equalCodegenTypeInfo)(result, propertyType)) {
            throw new Error(`Found mismatching type for discriminator property "${serializedName}" for "${container.name}" in "${schema.name}": ${(0, utils_1.typeInfoToString)(propertyType)} vs ${(0, utils_1.typeInfoToString)(result)}`);
        }
    }
    if (!result) {
        throw new Error(`Discriminator property "${serializedName}" missing from all schemas for "${container.name}"`);
    }
    return result;
}
/**
 * Return the appropriate discriminator value to use for the given schema
 * @param discriminator the discriminator
 * @param schema the discriminatable schema to find the value for
 * @returns
 */
function discriminatorValueForSchema(discriminator, schema, state) {
    const name = schema.serializedName || schema.name;
    if (!discriminator.mappings) {
        return name;
    }
    for (const [$ref, value] of idx.iterable(discriminator.mappings)) {
        const resolvedSchema = (0, utils_1.resolveReference)({
            $ref,
        }, state);
        const found = (0, utils_2.findKnownSchema)(resolvedSchema, $ref, state);
        if (found === schema) {
            return value;
        }
    }
    return name;
}
/**
 * Add a new member to the discriminator in the discriminatorSchema.
 * @param discriminatorSchema
 * @param memberSchema
 * @param state
 * @returns
 */
function addToDiscriminator(discriminatorSchema, memberSchema, state) {
    if (!discriminatorSchema.discriminator) {
        return;
    }
    /* Check if we've already added this memberSchema */
    if (discriminatorSchema.discriminator.references.find(r => r.schema === memberSchema)) {
        return;
    }
    if ((0, types_1.isCodegenObjectLikeSchema)(memberSchema)) {
        const property = (0, utils_2.findProperty)(memberSchema, discriminatorSchema.discriminator.serializedName);
        if (!property) {
            throw new Error(`Discriminator property "${discriminatorSchema.discriminator.serializedName}" for "${discriminatorSchema.name}" missing from "${memberSchema.name}"`);
        }
        if (!property.discriminators) {
            property.discriminators = [];
        }
        property.discriminators.push(discriminatorSchema.discriminator);
    }
    const discriminatorValue = discriminatorValueForSchema(discriminatorSchema.discriminator, memberSchema, state);
    const discriminatorValueLiteral = state.generator.toLiteral(discriminatorValue, (0, utils_1.toCodegenDefaultValueOptions)(Object.assign(Object.assign({}, discriminatorSchema.discriminator), { required: true, nullable: false, readOnly: false, writeOnly: false })));
    if (!discriminatorValueLiteral) {
        throw new Error(`Discriminator value "${discriminatorValue}" cannot be converted to literal for property "${discriminatorSchema.discriminator.serializedName}" in "${memberSchema.name}"`);
    }
    discriminatorSchema.discriminator.references.push({
        schema: memberSchema,
        value: discriminatorValue,
        literalValue: discriminatorValueLiteral,
    });
    if (!memberSchema.discriminatorValues) {
        memberSchema.discriminatorValues = [];
    }
    memberSchema.discriminatorValues.push({
        schema: discriminatorSchema,
        value: discriminatorValue,
        literalValue: discriminatorValueLiteral,
    });
}
exports.addToDiscriminator = addToDiscriminator;
/**
 * Find any discriminators in the parent, and add the target to those discriminators
 * @param parent
 * @param target
 * @param state
 */
function addToAnyDiscriminators(parent, target, state) {
    const discriminatorSchemas = findDiscriminatorSchemas(parent);
    for (const aDiscriminatorSchema of discriminatorSchemas) {
        addToDiscriminator(aDiscriminatorSchema, target, state);
    }
}
exports.addToAnyDiscriminators = addToAnyDiscriminators;
/**
 * Find any schemas with discriminators in the given schema and its parents
 * @param schema
 * @returns
 */
function findDiscriminatorSchemas(schema) {
    const open = [schema];
    const result = [];
    for (const aSchema of open) {
        if ((0, types_1.isCodegenDiscriminatorSchema)(aSchema) && aSchema.discriminator) {
            result.push(aSchema);
        }
        if ((0, types_1.isCodegenObjectSchema)(aSchema)) {
            if (aSchema.parents) {
                open.push(...aSchema.parents.filter(s => open.indexOf(s) === -1));
            }
            if (aSchema.implements) {
                open.push(...aSchema.implements.filter(s => open.indexOf(s) === -1));
            }
        }
        else if ((0, types_1.isCodegenInterfaceSchema)(aSchema)) {
            if (aSchema.parents) {
                open.push(...aSchema.parents.filter(s => open.indexOf(s) === -1));
            }
        }
        else if ((0, types_1.isCodegenAllOfSchema)(aSchema)) {
            open.push(...aSchema.composes.filter(s => open.indexOf(s) === -1));
        }
    }
    return result;
}
/**
 * Post-process schemas to remove discriminator properties from objects. We don't remove the discriminator
 * properties earlier, as we need to keep them while we're reconciling all of the discriminators, and members,
 * as we try to find the discriminator property.
 * @param schema
 * @returns
 */
function postProcessSchemaForDiscriminator(schema) {
    if (!(0, types_1.isCodegenDiscriminatorSchema)(schema) || !schema.discriminator) {
        return;
    }
    const discriminator = schema.discriminator;
    /* Sort references so we generate in a consistent order */
    discriminator.references = discriminator.references.sort(compareDiscriminatorReferences);
    if ((0, types_1.isCodegenObjectLikeSchema)(schema) && schema.properties) {
        /* Check that the discriminator property isn't required for interface comformance */
        if (!(0, utils_2.interfaceForProperty)(schema, discriminator.serializedName)) {
            (0, utils_2.removeProperty)(schema, discriminator.serializedName);
        }
    }
    for (const reference of discriminator.references) {
        if ((0, types_1.isCodegenObjectLikeSchema)(reference.schema)) {
            /* Check that the discriminator property isn't required for interface comformance */
            if (!(0, utils_2.interfaceForProperty)(reference.schema, discriminator.serializedName)) {
                (0, utils_2.removeProperty)(reference.schema, discriminator.serializedName);
            }
        }
    }
}
exports.postProcessSchemaForDiscriminator = postProcessSchemaForDiscriminator;
function compareDiscriminatorReferences(a, b) {
    return a.value.toLowerCase().localeCompare(b.value.toLowerCase());
}
/**
 * Find schemas in other documents (not the root, which are all discovered automatically) that should be members of the discriminator
 * of the given schema, so that we find all such schemas that may exist in referenced docs. Otherwise we don't end up discovering and
 * outputting those schemas if they're not directly referenced.
 * @param discriminatorApiSchema
 * @param state
 * @returns
 */
function discoverDiscriminatorReferencesInOtherDocuments(discriminatorApiSchema, state) {
    return (0, _1.discoverSchemasInOtherDocuments)(createDiscriminatorMemberTestFunc(discriminatorApiSchema), state);
}
exports.discoverDiscriminatorReferencesInOtherDocuments = discoverDiscriminatorReferencesInOtherDocuments;
/**
 * Create a DiscoverRelatedSchemaTestFunc for finding schemas that reference the given discriminator schema.
 * @returns
 */
function createDiscriminatorMemberTestFunc(discriminatorApiSchema) {
    return function (anApiSchema, state) {
        if (anApiSchema.allOf) {
            const allOf = anApiSchema.allOf;
            for (const anAllOf of allOf) {
                if (anAllOf === discriminatorApiSchema) {
                    return true;
                }
                const resolved = (0, utils_1.resolveReference)(anAllOf, state);
                if (resolved === discriminatorApiSchema) {
                    return true;
                }
            }
        }
        return false;
    };
}
