"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toUniqueName = exports.extractNaming = exports.usedSchemaName = exports.fullyQualifiedName = exports.toUniqueScopedName = void 0;
const vendor_extensions_1 = require("../vendor-extensions");
const utils_1 = require("../utils");
const idx = __importStar(require("@openapi-generator-plus/indexed-type"));
const utils_2 = require("./utils");
function toScopedName($ref, suggestedName, scope, apiSchema, schemaType, state) {
    if ($ref) {
        /* We always want referenced schemas to be at the top-level */
        scope = null;
        suggestedName = (0, utils_1.nameFromRef)($ref, state);
    }
    if (apiSchema) {
        const vendorExtensions = (0, vendor_extensions_1.toCodegenVendorExtensions)(apiSchema);
        /* Support vendor extension to override the automatic naming of schemas */
        if (vendorExtensions && vendorExtensions['x-schema-name']) {
            suggestedName = String(vendorExtensions['x-schema-name']);
        }
    }
    const nameOptions = {
        schemaType,
    };
    let name = state.generator.toSchemaName(suggestedName, nameOptions);
    const serializedName = $ref ? ((0, utils_1.nameFromRef)($ref, state) || null) : null;
    if (scope) {
        /* Check that our name is unique in our scope, as some languages (Java) don't allow an inner class to shadow the
           name of a containing class.
         */
        name = toUniqueName(name, scope.scopedName, possibleName => scope.scopedName.indexOf(possibleName) === -1, state);
        return {
            name,
            scopedName: [...scope.scopedName, name],
            serializedName,
            scope,
            anonymous: serializedName === null,
            $ref,
        };
    }
    else {
        return {
            name,
            scopedName: [name],
            serializedName,
            scope: null,
            anonymous: serializedName === null,
            $ref,
        };
    }
}
function toUniqueScopedName($ref, suggestedName, scope, apiSchema, schemaType, state) {
    const result = toScopedName($ref, suggestedName, scope, apiSchema, schemaType, state);
    const reservedName = (0, utils_2.reservedSchemaName)($ref, state);
    if (reservedName !== fullyQualifiedName(result.scopedName)) {
        /* Model types that aren't defined in the spec need to be made unique */
        result.scopedName = uniqueScopedName(result.scopedName, state);
        result.name = result.scopedName[result.scopedName.length - 1];
    }
    return result;
}
exports.toUniqueScopedName = toUniqueScopedName;
/**
 * Returns a fully qualified schema name using an internal format for creating fully qualified
 * model names. This format does not need to reflect a native format as it is only used internally
 * to track unique schema names.
 * @param scopedName the scoped schema name
 */
function fullyQualifiedName(scopedName) {
    return scopedName.join('.');
}
exports.fullyQualifiedName = fullyQualifiedName;
/**
 * Record that the given schema name has been used.
 * @param scopedName
 * @param state
 */
function usedSchemaName(scopedName, state) {
    state.usedFullyQualifiedSchemaNames[fullyQualifiedName(scopedName)] = true;
}
exports.usedSchemaName = usedSchemaName;
/**
 * Returns a unique model name for a proposed schema name.
 * @param scopeNamed the scoped schema name
 * @param state the state
 */
function uniqueScopedName(scopedName, state) {
    const proposedName = scopedName[scopedName.length - 1];
    const parentNames = scopedName.slice(0, scopedName.length - 1);
    const name = toUniqueName(proposedName, parentNames, possibleName => !state.usedFullyQualifiedSchemaNames[fullyQualifiedName([...parentNames, possibleName])], state);
    return [...parentNames, name];
}
function extractNaming(naming) {
    if (!naming) {
        return {
            name: null,
            scopedName: null,
            serializedName: null,
            anonymous: null,
        };
    }
    return {
        name: naming.name,
        scopedName: naming.scopedName,
        serializedName: naming.serializedName,
        anonymous: naming.anonymous,
    };
}
exports.extractNaming = extractNaming;
function toUniqueName(suggestedName, parentNames, testOrData, state) {
    if (!testOrData) {
        return suggestedName;
    }
    const testUniqueName = typeof testOrData === 'function' ? testOrData : (possibleName) => uniqueNameInIndexedCollection(possibleName, testOrData);
    let name = suggestedName;
    let iteration = 0;
    while (!testUniqueName(name, parentNames)) {
        iteration += 1;
        name = state.generator.toIteratedSchemaName(suggestedName, parentNames, iteration);
    }
    return name;
}
exports.toUniqueName = toUniqueName;
/**
 * Returns `true` if the given name is unique in the collection of objects with names.
 * @param name a possible name
 * @param collection a collection of objects with names
 * @returns
 */
function uniqueNameInIndexedCollection(name, collection) {
    for (const value of idx.allValues(collection)) {
        if (value.name === name) {
            return false;
        }
    }
    return true;
}
