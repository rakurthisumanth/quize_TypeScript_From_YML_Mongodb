"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodegenInterfaceImplementationSchema = exports.toCodegenInterfaceSchema = void 0;
const types_1 = require("@openapi-generator-plus/types");
const utils_1 = require("../utils");
const naming_1 = require("./naming");
const object_1 = require("./object");
const object_absorb_1 = require("./object-absorb");
const utils_2 = require("./utils");
/**
 * Create or return an interface schema for the given object schema
 * @param schema
 * @returns
 */
function toCodegenInterfaceSchema(schema, scope, state) {
    if (schema.interface) {
        return schema.interface;
    }
    if (!state.generator.interfaceCanBeNested()) {
        scope = null;
    }
    /* Create interfaces for parents */
    let parents = null;
    if (schema.parents) {
        parents = [];
        for (const parentSchema of schema.parents) {
            parents.push(toCodegenInterfaceSchema(parentSchema, (0, utils_2.scopeOf)(parentSchema, state), state));
        }
    }
    /* Get a name for this interface */
    const suggestedName = state.generator.toSuggestedSchemaName(schema.name, {
        purpose: types_1.CodegenSchemaPurpose.EXTRACTED_INTERFACE,
        schemaType: types_1.CodegenSchemaType.INTERFACE,
    });
    const naming = (0, naming_1.toUniqueScopedName)(undefined, suggestedName, scope, undefined, types_1.CodegenSchemaType.INTERFACE, state);
    (0, naming_1.usedSchemaName)(naming.scopedName, state);
    const nativeType = state.generator.toNativeObjectType({
        type: 'object',
        schemaType: types_1.CodegenSchemaType.INTERFACE,
        scopedName: naming.scopedName,
        vendorExtensions: schema.vendorExtensions,
    });
    const result = Object.assign(Object.assign(Object.assign({}, (0, naming_1.extractNaming)(naming)), (0, utils_1.extractCodegenSchemaInfo)(schema)), { discriminator: schema.discriminator, discriminatorValues: schema.discriminatorValues, polymorphic: false, vendorExtensions: schema.vendorExtensions, externalDocs: schema.externalDocs, nativeType, type: 'object', format: null, description: schema.description, title: schema.title, schemaType: types_1.CodegenSchemaType.INTERFACE, component: null, deprecated: schema.deprecated, additionalProperties: schema.additionalProperties, properties: schema.properties, examples: null, children: null, implementation: (0, types_1.isCodegenObjectSchema)(schema) ? schema : null, implementors: null, parents: null, schemas: null });
    schema.interface = result;
    if ((0, types_1.isCodegenObjectSchema)(schema)) {
        (0, utils_2.addImplementor)(result, schema);
    }
    if (parents) {
        for (const aParent of parents) {
            (0, utils_2.addChildInterfaceSchema)(aParent, result);
        }
    }
    (0, utils_2.addToScope)(result, scope, state);
    return result;
}
exports.toCodegenInterfaceSchema = toCodegenInterfaceSchema;
/**
 * Create or return the implementation schema for the given interface schema.
 * @param schema
 * @param suggestedAbstract `true` if the implementation could be an abstract implementation
 * @returns a CodegenObjectSchema, or undefined if an implementation cannot be created
 */
function toCodegenInterfaceImplementationSchema(interfaceSchema, options, state) {
    const { allowAbstract } = options;
    if (interfaceSchema.implementation) {
        if (!allowAbstract && interfaceSchema.implementation.abstract) {
            // We could try to change it to not abstract and correct its name
            throw new Error(`Existing interface implementation "${interfaceSchema.implementation.name}" for "${interfaceSchema.name}" is abstract`);
        }
        return interfaceSchema.implementation;
    }
    const scope = (0, utils_2.scopeOf)(interfaceSchema, state);
    const suggestedName = options.suggestedName || interfaceSchema.serializedName || interfaceSchema.name;
    const result = (0, object_1.createObjectSchema)(suggestedName, scope, allowAbstract ? types_1.CodegenSchemaPurpose.ABSTRACT_IMPLEMENTATION : types_1.CodegenSchemaPurpose.IMPLEMENTATION, state);
    result.abstract = allowAbstract;
    result.properties = interfaceSchema.properties;
    result.additionalProperties = interfaceSchema.additionalProperties;
    (0, utils_2.addImplementor)(interfaceSchema, result);
    interfaceSchema.implementation = result;
    result.interface = interfaceSchema;
    /* Create and extend implementations from interface parents */
    if (interfaceSchema.parents) {
        if (state.generator.supportsInheritance() && (interfaceSchema.parents.length === 1 || state.generator.supportsMultipleInheritance())) {
            for (const aParent of interfaceSchema.parents) {
                const aParentImplementation = toCodegenInterfaceImplementationSchema(aParent, { allowAbstract: true }, state);
                if (aParentImplementation) {
                    (0, utils_2.addChildObjectSchema)(aParentImplementation, result);
                }
                else {
                    throw new Error(`Cannot create implementation for "${(0, naming_1.fullyQualifiedName)(aParent.scopedName)}`);
                }
            }
        }
        else {
            for (const aParent of interfaceSchema.parents) {
                (0, object_absorb_1.absorbCodegenSchema)(aParent, result, {});
            }
        }
    }
    return result;
}
exports.toCodegenInterfaceImplementationSchema = toCodegenInterfaceImplementationSchema;
