"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.refForPathAndSchemaName = exports.refForSchemaName = exports.reservedSchemaName = exports.addReservedSchemaName = exports.addImplementor = exports.addChildInterfaceSchema = exports.addChildObjectSchema = exports.findPropertyAndSchema = exports.findProperty = exports.removeProperty = exports.interfaceForProperty = exports.addToKnownSchemas = exports.findKnownSchema = exports.scopeOf = exports.addToScope = exports.extractCodegenSchemaCommon = void 0;
const types_1 = require("@openapi-generator-plus/types");
const openapi_type_guards_1 = require("../../openapi-type-guards");
const idx = __importStar(require("@openapi-generator-plus/indexed-type"));
const naming_1 = require("./naming");
const utils_1 = require("../utils");
const utils_2 = require("@openapi-generator-plus/utils");
const path_1 = __importDefault(require("path"));
/**
 * Extract the common attributes that we use from OpenAPI schema in our CodegenSchema.
 * @param apiSchema an OpenAPI schema
 * @param state
 */
function extractCodegenSchemaCommon(apiSchema, state) {
    return {
        description: apiSchema.description || null,
        title: apiSchema.title || null,
        readOnly: (0, utils_1.convertToBoolean)(apiSchema.readOnly, false),
        nullable: (0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion) ? (0, utils_1.convertToBoolean)(apiSchema.nullable, false) : false,
        writeOnly: (0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion) ? (0, utils_1.convertToBoolean)(apiSchema.writeOnly, false) : false,
        deprecated: (0, openapi_type_guards_1.isOpenAPIv3SchemaObject)(apiSchema, state.specVersion) ? (0, utils_1.convertToBoolean)(apiSchema.deprecated, false) : false,
    };
}
exports.extractCodegenSchemaCommon = extractCodegenSchemaCommon;
function addToScope(schema, scope, state) {
    if (!(0, types_1.isCodegenNamedSchema)(schema)) {
        throw new Error(`Cannot add schema without a name to a scope: ${(0, utils_2.debugStringify)(schema)}`);
    }
    if (scope) {
        if (!scope.schemas) {
            scope.schemas = idx.create();
        }
        idx.set(scope.schemas, schema.name, schema);
    }
    else {
        idx.set(state.schemas, schema.name, schema);
    }
}
exports.addToScope = addToScope;
/**
 * Returns the scope of the given schema
 * @param schema
 * @param state
 * @returns a CodegenScope, or null if it is in the global scope
 */
function scopeOf(schema, state) {
    const scopedName = schema.scopedName;
    if (scopedName.length === 1) {
        return null;
    }
    let result = idx.get(state.schemas, scopedName[0]);
    for (let i = 1; i < scopedName.length; i++) {
        if (!result) {
            break;
        }
        else if ((0, types_1.isCodegenScope)(result)) {
            if (result.schemas) {
                result = idx.get(result.schemas, scopedName[i]);
            }
            else {
                result = undefined;
                break;
            }
        }
        else {
            break;
        }
    }
    if (result && (0, types_1.isCodegenScope)(result)) {
        return result;
    }
    else {
        throw new Error(`Could not lookup scope of ${(0, naming_1.fullyQualifiedName)(scopedName)}`);
    }
}
exports.scopeOf = scopeOf;
/**
 * Normalise a $ref so that the path to external files is canonical, so we can use them to lookup known schemas.
 * @param $ref
 * @param state
 * @returns
 */
function normaliseRef($ref, state) {
    if ($ref === undefined) {
        return undefined;
    }
    if ($ref.startsWith('#')) {
        const base = state.$refs.paths()[0];
        return `${base}${$ref}`;
    }
    else if (!$ref.startsWith('/')) {
        const base = state.$refs.paths()[0];
        const result = path_1.default.resolve(path_1.default.dirname(base), $ref);
        return result;
    }
    else {
        return $ref;
    }
}
function findKnownSchema(apiSchema, $ref, state) {
    const known = state.knownSchemas.get(apiSchema);
    if (known) {
        return known;
    }
    if ($ref) {
        const known = state.knownSchemasByRef.get(normaliseRef($ref, state));
        if (known) {
            return known;
        }
    }
    return undefined;
}
exports.findKnownSchema = findKnownSchema;
/**
 * Add the result to the knownSchemas to avoid generating again, and returns the canonical schema.
 * If theres already a known schema for the given schema, the already existing version is returned.
 * This helps to dedupe what we generate.
 */
function addToKnownSchemas(apiSchema, schema, naming, state) {
    const existing = state.knownSchemas.get(apiSchema);
    if (!existing) {
        state.knownSchemas.set(apiSchema, schema);
    }
    let existingByRef;
    if (naming === null || naming === void 0 ? void 0 : naming.$ref) {
        const normalisedRef = normaliseRef(naming.$ref, state);
        existingByRef = (naming === null || naming === void 0 ? void 0 : naming.$ref) ? state.knownSchemasByRef.get(normalisedRef) : undefined;
        if (!existingByRef) {
            state.knownSchemasByRef.set(normalisedRef, schema);
        }
    }
    if (existing) {
        return existing;
    }
    else if (existingByRef) {
        return existingByRef;
    }
    else {
        return schema;
    }
}
exports.addToKnownSchemas = addToKnownSchemas;
/**
 * Returns the interface, if any, that the property in the given schema implements in one of the interfaces the schema implements.
 * @param schema
 * @param serializedName
 * @returns
 */
function interfaceForProperty(schema, serializedName) {
    if ((0, types_1.isCodegenObjectSchema)(schema)) {
        if (schema.implements !== null) {
            for (const anInterface of schema.implements) {
                const [property, propertySchema] = findPropertyAndSchema(anInterface, serializedName);
                if (property) {
                    return propertySchema;
                }
            }
        }
    }
    return undefined;
}
exports.interfaceForProperty = interfaceForProperty;
/**
 * Finds and removes the named property from the given set of properties.
 * @param properties the properties to look in
 * @param serializedName the serialized name of the property
 * @returns a CodegenProperty or undefined if not found
 */
function removeProperty(schema, serializedName) {
    if (!schema.properties) {
        return undefined;
    }
    const entry = idx.get(schema.properties, serializedName);
    if (!entry) {
        return undefined;
    }
    idx.remove(schema.properties, serializedName);
    if (idx.isEmpty(schema.properties)) {
        /* Check for schemas that share these properties */
        if ((0, types_1.isCodegenObjectSchema)(schema) && schema.interface && schema.interface.properties === schema.properties) {
            schema.interface.properties = null;
        }
        if ((0, types_1.isCodegenInterfaceSchema)(schema) && schema.implementation && schema.implementation.properties === schema.properties) {
            schema.implementation.properties = null;
        }
        schema.properties = null;
    }
    return entry;
}
exports.removeProperty = removeProperty;
function findProperty(schema, serializedName) {
    const [property] = findPropertyAndSchema(schema, serializedName);
    return property;
}
exports.findProperty = findProperty;
/**
 * Looks for the named property in the current schema and any parents etc.
 * @param schema
 * @param serializedName
 * @returns
 */
function findPropertyAndSchema(schema, serializedName) {
    const open = [schema];
    for (const aSchema of open) {
        if (aSchema.properties) {
            const property = idx.get(aSchema.properties, serializedName);
            if (property) {
                return [property, aSchema];
            }
        }
        if ((0, types_1.isCodegenObjectSchema)(aSchema) && aSchema.parents) {
            for (const parent of aSchema.parents) {
                if (open.indexOf(parent) === -1) {
                    open.push(parent);
                }
            }
        }
        else if ((0, types_1.isCodegenInterfaceSchema)(aSchema) && aSchema.parents) {
            for (const parent of aSchema.parents) {
                if (open.indexOf(parent) === -1) {
                    open.push(parent);
                }
            }
        }
    }
    return [undefined, undefined];
}
exports.findPropertyAndSchema = findPropertyAndSchema;
function addChildObjectSchema(parent, child) {
    if (!parent.children) {
        parent.children = [];
    }
    parent.children.push(child);
    if (!child.parents) {
        child.parents = [];
    }
    child.parents.push(parent);
}
exports.addChildObjectSchema = addChildObjectSchema;
function addChildInterfaceSchema(parent, child) {
    if (!parent.children) {
        parent.children = [];
    }
    parent.children.push(child);
    if (!child.parents) {
        child.parents = [];
    }
    child.parents.push(parent);
}
exports.addChildInterfaceSchema = addChildInterfaceSchema;
function addImplementor(parent, child) {
    if (!parent.implementors) {
        parent.implementors = [];
    }
    parent.implementors.push(child);
    if (!child.implements) {
        child.implements = [];
    }
    child.implements.push(parent);
}
exports.addImplementor = addImplementor;
function addReservedSchemaName(schemaName, state) {
    const fqn = (0, naming_1.fullyQualifiedName)([schemaName]);
    const $ref = normaliseRef(refForSchemaName(schemaName, state), state);
    state.reservedSchemaNames[$ref] = fqn;
}
exports.addReservedSchemaName = addReservedSchemaName;
function reservedSchemaName($ref, state) {
    if (!$ref) {
        return undefined;
    }
    $ref = normaliseRef($ref, state);
    return state.reservedSchemaNames[$ref];
}
exports.reservedSchemaName = reservedSchemaName;
/**
 * Returns the value of the `$ref` to use to refer to the given schema definition / component.
 * @param schemaName the name of a schema
 * @param state
 */
function refForSchemaName(schemaName, state) {
    return (0, openapi_type_guards_1.isOpenAPIV2Document)(state.root) ? `#/definitions/${schemaName}` : `#/components/schemas/${schemaName}`;
}
exports.refForSchemaName = refForSchemaName;
/**
 * Returns the value of the `$ref` to use to refer to the given schema in an external document.
 * @param path the path to the external schema
 * @param doc the external schema document
 * @param schemaName the name of the schema
 * @param state
 * @returns
 */
function refForPathAndSchemaName(path, doc, schemaName, state) {
    return normaliseRef((0, openapi_type_guards_1.isOpenAPIV2Document)(doc) ? `${path}#/definitions/${schemaName}` : `${path}#/components/schemas/${schemaName}`, state);
}
exports.refForPathAndSchemaName = refForPathAndSchemaName;
