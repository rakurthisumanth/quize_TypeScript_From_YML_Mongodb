import { CodegenNamedSchema, CodegenSchema, CodegenSchemaType, CodegenScope, IndexedCollectionType } from '@openapi-generator-plus/types';
import { InternalCodegenState } from '../../types';
import { OpenAPIX } from '../../types/patches';
export interface ScopedModelInfo {
    name: string;
    scopedName: string[];
    serializedName: string | null;
    scope: CodegenScope | null;
    anonymous: boolean;
    $ref: string | undefined;
}
export declare function toUniqueScopedName($ref: string | undefined, suggestedName: string, scope: CodegenScope | null, apiSchema: OpenAPIX.SchemaObject | undefined, schemaType: CodegenSchemaType, state: InternalCodegenState): ScopedModelInfo;
/**
 * Returns a fully qualified schema name using an internal format for creating fully qualified
 * model names. This format does not need to reflect a native format as it is only used internally
 * to track unique schema names.
 * @param scopedName the scoped schema name
 */
export declare function fullyQualifiedName(scopedName: string[]): string;
/**
 * Record that the given schema name has been used.
 * @param scopedName
 * @param state
 */
export declare function usedSchemaName(scopedName: string[], state: InternalCodegenState): void;
declare type ExtractNamingKeys = 'name' | 'scopedName' | 'serializedName' | 'anonymous';
export declare function extractNaming(naming: ScopedModelInfo): Pick<CodegenNamedSchema, ExtractNamingKeys>;
export declare function extractNaming(naming: ScopedModelInfo | null): Pick<CodegenSchema, ExtractNamingKeys>;
declare type TestUniqueNameFunc = (name: string, parentNames: string[] | undefined) => boolean;
interface WithName {
    name: string;
}
export declare function toUniqueName(suggestedName: string, parentNames: string[] | undefined, existingNames: IndexedCollectionType<WithName> | null, state: InternalCodegenState): string;
export declare function toUniqueName(suggestedName: string, parentNames: string[] | undefined, testUniqueName: TestUniqueNameFunc, state: InternalCodegenState): string;
export {};
